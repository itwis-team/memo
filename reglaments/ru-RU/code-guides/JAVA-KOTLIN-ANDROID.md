# Разработчик

Традиционно существует 3 роли управления проектами:
- Менеджер по продажам - отвечает за привлечение новых клиентов в компанию.
- Акаунт менеджер - поддерживает продолжительную связь с клиентами.
- Менеджер проектов - отвечает за успешное выполнение клиентов проекта.

В iTwis роли Менеджера по продажам и Акаунт менеджера совмещены в одном человеке. Это совмещение обусловлено следующими соображениями: Выделение отдельного человека на все 3 роли не целесообразно так как это будет некомфортно для клиента так как ему прийдется устанавливать слишком много новых контактов а первичный контакт уходит в тень сразу после продажи. Обединение всех трех ролей в одном человеки потребует от работника экстроардинарных компетенций. Так-же неудабным будет и любое другое объединение компетенций. А объединение ролей менеджера по продахам и акаунт менеджера позволит сормировать у клиента ощущение "своего" человека в компании.

### Правила работы с GitHub
Разработка в компании ведется

### Правила оформления кода

###### Отступ
Используйте четыре пробела для отступа. Не используйте вкладки.
Для фигурных скобок поместите открывающую скобку в конец строки, где начинается конструкция, а закрывающую скобку на отдельной строке, выровненной по горизонтали с открывающей конструкцией.

###### Завершающие запятые
Завершающая запятая — это символ запятой после последнего элемента последовательности элементов:
<class Person(
    val firstName: String,
    val lastName: String,
    val age: Int, // trailing comma
)>

Использование замыкающих запятых имеет несколько преимуществ:
- Это делает контроль версий чище, так как все внимание сосредоточено на измененном значении.
- Это упрощает добавление и изменение порядка элементов — нет необходимости добавлять или удалять запятую, если вы манипулируете элементами.
- Это упрощает генерацию кода, например, для инициализаторов объектов. Последний элемент также может иметь запятую.
- Завершающие запятые необязательны — ваш код будет работать и без них. Руководство по стилю Kotlin поощряет использование завершающих запятых в месте объявления и оставляет его на ваше усмотрение для места вызова.

###### Непустые блоки
Скобки следуют стилю Кернигана и Ритчи («египетские скобки») для непустых блоков и блочных конструкций:
- Нет разрыва строки перед открывающей фигурной скобкой.
- Разрыв строки после открывающей скобки.
- Разрыв строки перед закрывающей фигурной скобкой.
- Разрыв строки после закрывающей фигурной скобки, только если эта фигурная скобка завершает оператор или завершает тело функции, конструктора или именованного класса. Например, после фигурной скобки нет разрыва строки, если за ней следует запятая elseили .

###### Вертикальный пробел
Появляется одна пустая строка:

- Между последовательными членами класса: свойствами, конструкторами, функциями, вложенными классами и т. д.
    - Исключение: Пустая строка между двумя последовательными свойствами (без другого кода между ними) является необязательной. Такие пустые строки используются по мере необходимости для создания логических групп свойств и связывания свойств с их вспомогательным свойством, если оно присутствует.
    - Исключение: пустые строки между константами перечисления рассматриваются ниже.
- Между операторами, если это необходимо для организации кода в логические подразделы.
- Необязательно перед первым оператором в функции, перед первым членом класса или после последнего члена класса (ни поощряется, ни обескураживает).
- В соответствии с требованиями других разделов этого документа (например, раздела «Структура» ).
  Несколько последовательных пустых строк разрешены, но не поощряются и не требуются.

###### Горизонтальные пробелы
- Ставьте пробелы вокруг бинарных операторов ( a + b). Исключение: не ставьте пробелы вокруг оператора «диапазон до» ( 0..i).
- Не ставьте пробелы вокруг унарных операторов ( a++).
- Поместите пробелы между ключевыми словами потока управления ( if, when, forи while) и соответствующей открывающей скобкой.
- Не ставьте пробел перед открывающей скобкой в объявлении основного конструктора, объявлении метода или вызове метода.
- Никогда не ставьте пробел после (, [или перед ],)
- Никогда не ставьте пробел вокруг .или ?.
- Ставьте пробел после //
- Не ставьте пробелы вокруг угловых скобок, используемых для указания параметров типа:class Map<K, V> { ... }
- Не ставьте пробелы вокруг ::: Foo::class,String::length
- Не ставьте пробел перед ?использованием для обозначения типа, допускающего значение NULL:String?
  Как правило, избегайте любого горизонтального выравнивания. Переименование идентификатора в имя другой длины не должно влиять ни на форматирование объявления, ни на какое-либо использование.

###### Классы перечисления
Перечисление без функций и без документации по его константам может быть отформатировано как одна строка.
<enum class Answer { YES, NO, MAYBE }>

Когда константы в перечислении размещаются на отдельных строках, пустая строка между ними не требуется, за исключением случаев, когда они определяют тело.
<enum class Answer {
    YES,
    NO,
    MAYBE {
       override fun toString() = """¯\_(ツ)_/¯"""
    }
}>

Поскольку перечисляемые классы являются классами, применяются все остальные правила форматирования классов.

###### Имена пакетов
Все имена пакетов написаны строчными буквами, а последовательные слова просто объединены вместе (без подчеркивания).
<// Okay
package com.example.deepspace
// WRONG!
package com.example.deepSpace
// WRONG!
package com.example.deep_space>

###### Постоянные имена
В именах констант используется UPPER_SNAKE_CASE: все буквы в верхнем регистре, слова разделены символами подчеркивания

###### Непостоянные имена
Непостоянные имена пишутся в camelCase. Они применяются к свойствам экземпляра, локальным свойствам и именам параметров.

###### Имена функций
Имена функций записываются в CamelCase и обычно представляют собой глаголы или глагольные фразы. Например, sendMessageили stop.

Разрешается использовать символы подчеркивания в именах тестовых функций для разделения логических компонентов имени.

###### Имена типов
Имена классов записываются в PascalCase и обычно являются существительными или словосочетаниями. Например, Characterили ImmutableList. Имена интерфейсов также могут быть существительными или именными словосочетаниями (например, List), но иногда могут быть прилагательными или прилагательными словосочетаниями (например, Readable).

Имена тестовых классов начинаются с имени класса, который они тестируют, и заканчиваются на Test. Например, HashTestили HashIntegrationTest.

###### Двоеточие
Ставьте пробел перед :в следующих случаях:
- когда он используется для разделения типа и супертипа
- при делегировании конструктору суперкласса или другому конструктору того же класса
- после objectключевого слова
- Не ставьте пробел перед :тем, когда он разделяет объявление и его тип.
- Всегда ставьте пробел после :.

###### Заголовки классов
Классы с несколькими основными параметрами конструктора можно записать в одну строку:
<class Person(id: Int, name: String)>

Классы с более длинными заголовками должны быть отформатированы так, чтобы каждый параметр основного конструктора находился в отдельной строке с отступом. Кроме того, закрывающая скобка должна быть на новой строке. Если вы используете наследование, вызов конструктора суперкласса или список реализованных интерфейсов должен располагаться на той же строке, что и скобка:
<class Person(
    id: Int,
    name: String,
    surname: String
) : Human(id, name) { /*...*/ }>

Для нескольких интерфейсов вызов конструктора суперкласса должен быть расположен первым, а затем каждый интерфейс должен быть расположен в отдельной строке:
<class Person(
    id: Int,
    name: String,
    surname: String
) : Human(id, name),
KotlinMaker { /*...*/ }>

Для классов с длинным списком супертипов поставьте разрыв строки после двоеточия и выровняйте все имена супертипов по горизонтали:
<class MyFavouriteVeryLongClassHolder :
    MyLongHolder<MyFavouriteVeryLongClass>(),
    SomeOtherInterface,
    AndAnotherOne {
    fun foo() { /*...*/ }
}>

Чтобы четко разделить заголовок и тело класса, когда заголовок класса длинный, либо поместите пустую строку после заголовка класса (как в приведенном выше примере), либо поместите открывающую фигурную скобку в отдельную строку:
<class MyFavouriteVeryLongClassHolder :
    MyLongHolder<MyFavouriteVeryLongClass>(),
    SomeOtherInterface,
    AndAnotherOne
{
    fun foo() { /*...*/ }
}>

Используйте обычный отступ (четыре пробела) для параметров конструктора. Это гарантирует, что свойства, объявленные в основном конструкторе, имеют тот же отступ, что и свойства, объявленные в теле класса.

###### Аннотации
Размещайте аннотации на отдельных строках перед объявлением, к которому они присоединены, и с тем же отступом:
<@Target(AnnotationTarget.PROPERTY)
annotation class JsonExclude>

Аннотации без аргументов могут быть размещены на той же строке:
<@JsonExclude @JvmField
var x: String>

Одна аннотация без аргументов может быть размещена на той же строке, что и соответствующее объявление:
<@Test fun foo() { /*...*/ }>

###### Функции
Если сигнатура функции не помещается на одной строке, используйте следующий синтаксис:
<fun longMethodName(
    argument: ArgumentType = defaultValue,
    argument2: AnotherArgumentType,
): ReturnType {
    // body
}>

Используйте обычный отступ (четыре пробела) для параметров функции. Это помогает обеспечить согласованность с параметрами конструктора.

Для функций лучше использовать тело выражения, тело которого состоит из одного выражения.
<fun foo(): Int {     // bad
    return 1
}

fun foo() = 1        // good>

###### Tела экспрессии
Если у функции есть тело выражения, первая строка которого не помещается на той же строке, что и объявление, поставьте знак =на первой строке и сделайте отступ тела выражения на четыре пробела.
<fun f(x: String, y: String, z: String) =
    veryLongFunctionCallWithManyWords(andLongParametersToo(), x, y, z)>

###### Вызовы методов
В длинных списках аргументов ставьте разрыв строки после открывающей скобки. Аргументы с отступом в четыре пробела. Сгруппируйте несколько тесно связанных аргументов в одной строке.
<drawSquare(
    x = 10, y = 10,
    width = 100, height = 100,
    fill = true
)>

Поместите пробелы вокруг =знака, разделяющего имя аргумента и значение.

###### Перенос связанных вызовов
При переносе связанных вызовов поместите .символ или ?.оператор на следующую строку с одним отступом:
<val anchor = owner
    ?.firstChild!!
    .siblings(forward = true)
    .dropWhile { it is PsiComment || it is PsiWhiteSpace }>

Перед первым вызовом в цепочке обычно должен быть разрыв строки, но его можно опустить, если код имеет больше смысла.

###### Лямбды
В лямбда-выражениях следует использовать пробелы вокруг фигурных скобок, а также вокруг стрелки, отделяющей параметры от тела. Если вызов принимает одну лямбду, передайте ее вне круглых скобок, когда это возможно.
<list.filter { it > 10 }>

При назначении метки для лямбды не ставьте пробел между меткой и открывающей фигурной скобкой:
<fun foo() {
    ints.forEach lit@{
        // ...
    }
}>

При объявлении имен параметров в многострочном лямбда-выражении поместите имена в первую строку, а затем стрелку и новую строку:
<appendCommaSeparated(properties) { prop ->
    val propertyValue = prop.get(obj)  // ...
}>

Если список параметров слишком длинный и не помещается на одной строке, поместите стрелку на отдельной строке:
<foo {
    context: Context,
    environment: Env
    ->
    context.configureEnv(environment)
}>
